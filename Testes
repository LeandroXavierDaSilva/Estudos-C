#include <stdlib.h> 
#include <stdio.h>
#include <time.h> 

#define NUM_SUB_IMAGENS 100

struct ImagemPGM {
    int largura;
    int altura;
    int valorMax;
    unsigned char** pixels;
};

struct ImagemPGM* lerImagemPGM(const char* nomeArquivo) {
    FILE* arquivo = fopen(nomeArquivo, "rb");

    if (arquivo == NULL) {
        printf("Erro ao abrir o arquivo de imagem.\n");
        return NULL;
    }

    // Lendo o cabeçalho da imagem PGM
    char formato[3];
    int largura, altura, valorMax;
    fscanf(arquivo, "%s %d %d %d", formato, &largura, &altura, &valorMax);

    // Alocando memória para a estrutura da imagem
    struct ImagemPGM* imagem = (struct ImagemPGM*)malloc(sizeof(struct ImagemPGM));
    imagem->largura = largura;
    imagem->altura = altura;
    imagem->valorMax = valorMax;

    // Alocando memória para os pixels da imagem
    imagem->pixels = (unsigned char**)malloc(altura * sizeof(unsigned char*));
    for (int i = 0; i < altura; i++) {
        imagem->pixels[i] = (unsigned char*)malloc(largura * sizeof(unsigned char));
    }

    // Lendo os dados dos pixels da imagem
    for (int i = 0; i < altura; i++) {
        fread(imagem->pixels[i], sizeof(unsigned char), largura, arquivo);
    }

    fclose(arquivo);
    return imagem;
}

void liberarImagemPGM(struct ImagemPGM* imagem) {
    for (int i = 0; i < imagem->altura; i++) {
        free(imagem->pixels[i]);
    }
    free(imagem->pixels);
    free(imagem);
}

void salvarSubImagemPGM(const char* nomeArquivo, struct ImagemPGM* subImagem) {
    FILE* arquivo = fopen(nomeArquivo, "wb");

    if (arquivo == NULL) {
        printf("Erro ao criar o arquivo de sub-imagem.\n");
        return;
    }

    // Escrevendo o cabeçalho da sub-imagem PGM
    fprintf(arquivo, "P5\n%d %d\n%d\n", subImagem->largura, subImagem->altura, subImagem->valorMax);

    // Escrevendo os dados dos pixels da sub-imagem
    for (int i = 0; i < subImagem->altura; i++) {
        fwrite(subImagem->pixels[i], sizeof(unsigned char), subImagem->largura, arquivo);
    }

    fclose(arquivo);
}

void aplicarFiltroMedia(struct ImagemPGM* imagem) {
    struct ImagemPGM* copiaImagem = (struct ImagemPGM*)malloc(sizeof(struct ImagemPGM));
    copiaImagem->largura = imagem->largura;
    copiaImagem->altura = imagem->altura;
    copiaImagem->valorMax = imagem->valorMax;
    copiaImagem->pixels = (unsigned char**)malloc(imagem->altura * sizeof(unsigned char*));

    // Copiar a imagem original para a cópia
    for (int i = 0; i < imagem->altura; i++) {
        copiaImagem->pixels[i] = (unsigned char*)malloc(imagem->largura * sizeof(unsigned char));
        for (int j = 0; j < imagem->largura; j++) {
            copiaImagem->pixels[i][j] = imagem->pixels[i][j];
        }
    }

    // Aplicar o filtro de média 3x3
    int kernel[3][3] = {
        {1, 1, 1},
        {1, 1, 1},
        {1, 1, 1}
    };

    for (int i = 1; i < imagem->altura - 1; i++) {
        for (int j = 1; j < imagem->largura - 1; j++) {
            int soma = 0;
            for (int k = -1; k <= 1; k++) {
                for (int l = -1; l <= 1; l++) {
                    soma += copiaImagem->pixels[i + k][j + l] * kernel[k + 1][l + 1];
                }
            }
            imagem->pixels[i][j] = soma / 9;
        }
    }

    // Liberar a memória alocada para a cópia da imagem
    for (int i = 0; i < copiaImagem->altura; i++) {
        free(copiaImagem->pixels[i]);
    }
    free(copiaImagem->pixels);
    free(copiaImagem);
}

void selecionarSubImagensAleatorias(struct ImagemPGM* imagem, int larguraSubImagem, int alturaSubImagem) {
    srand(time(NULL));

    int limiteHorizontal = imagem->largura - larguraSubImagem;
    int limiteVertical = imagem->altura - alturaSubImagem;

    for (int i = 0; i < NUM_SUB_IMAGENS; i++) {
        // Gerando coordenadas aleatórias para a sub-imagem
        int posX = rand() % limiteHorizontal;
        int posY = rand() % limiteVertical;

        // Criando a sub-imagem
        struct ImagemPGM* subImagem = (struct ImagemPGM*)malloc(sizeof(struct ImagemPGM));
        subImagem->largura = larguraSubImagem;
        subImagem->altura = alturaSubImagem;
        subImagem->valorMax = imagem->valorMax;

        // Alocando memória para os pixels da sub-imagem
        subImagem->pixels = (unsigned char**)malloc(alturaSubImagem * sizeof(unsigned char*));
        for (int j = 0; j < alturaSubImagem; j++) {
            subImagem->pixels[j] = (unsigned char*)malloc(larguraSubImagem * sizeof(unsigned char));
        }

        // Copiando os pixels da sub-imagem da imagem original
        for (int y = 0; y < alturaSubImagem; y++) {
            for (int x = 0; x < larguraSubImagem; x++) {
                subImagem->pixels[y][x] = imagem->pixels[posY + y][posX + x];
            }
        }

        // Aplicar o filtro de média com tratamento de bordas com zero
        aplicarFiltroMedia(subImagem);

        // Salvando a sub-imagem em um arquivo
        char nomeArquivo[20];
        sprintf(nomeArquivo, "subimagem_%d.pgm", i);
        salvarSubImagemPGM(nomeArquivo, subImagem);

        // Liberando a memória alocada para a sub-imagem
        for (int j = 0; j < alturaSubImagem; j++) {
            free(subImagem->pixels[j]);
        }
        free(subImagem->pixels);
        free(subImagem);
    }
}

int main() {
    const char* arquivoImagem = "columns.pgm";
    int larguraSubImagem = 100;
    int alturaSubImagem = 100;

    struct ImagemPGM* imagem = lerImagemPGM(arquivoImagem);
    if (imagem == NULL) {
        return 1;
    }

    selecionarSubImagensAleatorias(imagem, larguraSubImagem, alturaSubImagem);

    liberarImagemPGM(imagem);

    printf("As sub-imagens foram geradas com sucesso.\n");

    return 0;
}
